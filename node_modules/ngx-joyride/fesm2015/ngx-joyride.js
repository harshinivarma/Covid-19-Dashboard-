import { Injectable, Inject, PLATFORM_ID, EventEmitter, Directive, ViewContainerRef, Input, Output, RendererFactory2, Component, ViewEncapsulation, Injector, Renderer2, ViewChild, ComponentFactoryResolver, ApplicationRef, NgModule } from '@angular/core';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { ReplaySubject, of, Observable, Subject } from 'rxjs';
import { Router, RouterModule } from '@angular/router';
import { finalize } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/joyride-step.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideStep {
    constructor() {
        this.title = new ReplaySubject();
        this.text = new ReplaySubject();
    }
}
if (false) {
    /** @type {?} */
    JoyrideStep.prototype.name;
    /** @type {?} */
    JoyrideStep.prototype.route;
    /** @type {?} */
    JoyrideStep.prototype.position;
    /** @type {?} */
    JoyrideStep.prototype.title;
    /** @type {?} */
    JoyrideStep.prototype.text;
    /** @type {?} */
    JoyrideStep.prototype.stepContent;
    /** @type {?} */
    JoyrideStep.prototype.stepContentParams;
    /** @type {?} */
    JoyrideStep.prototype.nextClicked;
    /** @type {?} */
    JoyrideStep.prototype.prevCliked;
    /** @type {?} */
    JoyrideStep.prototype.tourDone;
    /** @type {?} */
    JoyrideStep.prototype.transformCssStyle;
    /** @type {?} */
    JoyrideStep.prototype.isElementOrAncestorFixed;
    /** @type {?} */
    JoyrideStep.prototype.targetViewContainer;
    /** @type {?} */
    JoyrideStep.prototype.stepInstance;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/joyride-options.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_THEME_COLOR = '#3b5560';
/** @type {?} */
const STEP_DEFAULT_POSITION = 'bottom';
/** @type {?} */
const DEFAULT_TIMEOUT_BETWEEN_STEPS = 1;
class ObservableCustomTexts {
}
if (false) {
    /** @type {?} */
    ObservableCustomTexts.prototype.prev;
    /** @type {?} */
    ObservableCustomTexts.prototype.next;
    /** @type {?} */
    ObservableCustomTexts.prototype.done;
    /** @type {?} */
    ObservableCustomTexts.prototype.close;
}
/** @type {?} */
const DEFAULT_TEXTS = {
    prev: of('prev'),
    next: of('next'),
    done: of('done'),
    close: of(null)
};
/**
 * @record
 */
function IJoyrideOptionsService() { }
if (false) {
    /**
     * @param {?} options
     * @return {?}
     */
    IJoyrideOptionsService.prototype.setOptions = function (options) { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getBackdropColor = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getThemeColor = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getStepDefaultPosition = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getStepsOrder = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getFirstStep = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getWaitingTime = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.areLogsEnabled = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.isCounterVisible = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.isPrevButtonVisible = function () { };
    /**
     * @return {?}
     */
    IJoyrideOptionsService.prototype.getCustomTexts = function () { };
}
class JoyrideOptionsService {
    constructor() {
        this.themeColor = DEFAULT_THEME_COLOR;
        this.stepDefaultPosition = STEP_DEFAULT_POSITION;
        this.logsEnabled = false;
        this.showCounter = true;
        this.showPrevButton = true;
        this.stepsOrder = [];
    }
    /**
     * @param {?} options
     * @return {?}
     */
    setOptions(options) {
        this.stepsOrder = options.steps;
        this.stepDefaultPosition = options.stepDefaultPosition
            ? options.stepDefaultPosition
            : this.stepDefaultPosition;
        this.logsEnabled =
            typeof options.logsEnabled !== 'undefined'
                ? options.logsEnabled
                : this.logsEnabled;
        this.showCounter =
            typeof options.showCounter !== 'undefined'
                ? options.showCounter
                : this.showCounter;
        this.showPrevButton =
            typeof options.showPrevButton !== 'undefined'
                ? options.showPrevButton
                : this.showPrevButton;
        this.themeColor = options.themeColor
            ? options.themeColor
            : this.themeColor;
        this.firstStep = options.startWith;
        this.waitingTime =
            typeof options.waitingTime !== 'undefined'
                ? options.waitingTime
                : DEFAULT_TIMEOUT_BETWEEN_STEPS;
        typeof options.customTexts !== 'undefined'
            ? this.setCustomText(options.customTexts)
            : this.setCustomText(DEFAULT_TEXTS);
    }
    /**
     * @return {?}
     */
    getBackdropColor() {
        return this.hexToRgb(this.themeColor);
    }
    /**
     * @return {?}
     */
    getThemeColor() {
        return this.themeColor;
    }
    /**
     * @return {?}
     */
    getStepDefaultPosition() {
        return this.stepDefaultPosition;
    }
    /**
     * @return {?}
     */
    getStepsOrder() {
        return this.stepsOrder;
    }
    /**
     * @return {?}
     */
    getFirstStep() {
        return this.firstStep;
    }
    /**
     * @return {?}
     */
    getWaitingTime() {
        return this.waitingTime;
    }
    /**
     * @return {?}
     */
    areLogsEnabled() {
        return this.logsEnabled;
    }
    /**
     * @return {?}
     */
    isCounterVisible() {
        return this.showCounter;
    }
    /**
     * @return {?}
     */
    isPrevButtonVisible() {
        return this.showPrevButton;
    }
    /**
     * @return {?}
     */
    getCustomTexts() {
        return this.customTexts;
    }
    /**
     * @private
     * @param {?} texts
     * @return {?}
     */
    setCustomText(texts) {
        /** @type {?} */
        let prev;
        /** @type {?} */
        let next;
        /** @type {?} */
        let done;
        /** @type {?} */
        let close;
        prev = texts.prev ? texts.prev : DEFAULT_TEXTS.prev;
        next = texts.next ? texts.next : DEFAULT_TEXTS.next;
        done = texts.done ? texts.done : DEFAULT_TEXTS.done;
        close = texts.close ? texts.close : DEFAULT_TEXTS.close;
        this.customTexts = (/** @type {?} */ ({
            prev: this.toObservable(prev),
            next: this.toObservable(next),
            done: this.toObservable(done),
            close: this.toObservable(close)
        }));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    toObservable(value) {
        return value instanceof Observable ? value : of(value);
    }
    /**
     * @private
     * @param {?} hex
     * @return {?}
     */
    hexToRgb(hex) {
        /** @type {?} */
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (/**
         * @param {?} m
         * @param {?} r
         * @param {?} g
         * @param {?} b
         * @return {?}
         */
        (m, r, g, b) => {
            return r + r + g + g + b + b;
        }));
        /** @type {?} */
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
            ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}`
            : null;
    }
}
JoyrideOptionsService.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.themeColor;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.stepDefaultPosition;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.logsEnabled;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.showCounter;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.showPrevButton;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.stepsOrder;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.firstStep;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.waitingTime;
    /**
     * @type {?}
     * @private
     */
    JoyrideOptionsService.prototype.customTexts;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/logger.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const JOYRIDE = 'ngx-joyride:::';
class LoggerService {
    /**
     * @param {?} optionService
     */
    constructor(optionService) {
        this.optionService = optionService;
    }
    /**
     * @param {?=} message
     * @param {?=} data
     * @return {?}
     */
    debug(message, data = "") {
        if (this.optionService.areLogsEnabled()) {
            console.debug(JOYRIDE + message, data);
        }
    }
    /**
     * @param {?=} message
     * @param {?=} data
     * @return {?}
     */
    info(message, data = "") {
        if (this.optionService.areLogsEnabled()) {
            console.info(JOYRIDE + message, data);
        }
    }
    /**
     * @param {?=} message
     * @param {?=} data
     * @return {?}
     */
    warn(message, data = "") {
        if (this.optionService.areLogsEnabled()) {
            console.warn(JOYRIDE + message, data);
        }
    }
    /**
     * @param {?=} message
     * @param {?=} data
     * @return {?}
     */
    error(message, data = "") {
        if (this.optionService.areLogsEnabled()) {
            console.error(JOYRIDE + message, data);
        }
    }
}
LoggerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LoggerService.ctorParameters = () => [
    { type: JoyrideOptionsService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.optionService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/joyride-error.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideError extends Error {
    /**
     * @param {?} message
     */
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, JoyrideError.prototype);
    }
}
class JoyrideStepDoesNotExist extends Error {
    /**
     * @param {?} message
     */
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, JoyrideStepDoesNotExist.prototype);
    }
}
class JoyrideStepOutOfRange extends Error {
    /**
     * @param {?} message
     */
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, JoyrideStepOutOfRange.prototype);
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/joyride-steps-container.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROUTE_SEPARATOR = '@';
class Step {
}
if (false) {
    /** @type {?} */
    Step.prototype.id;
    /** @type {?} */
    Step.prototype.step;
}
/** @enum {string} */
const StepActionType = {
    NEXT: "NEXT",
    PREV: "PREV",
};
class JoyrideStepsContainerService {
    /**
     * @param {?} stepOptions
     * @param {?} logger
     */
    constructor(stepOptions, logger) {
        this.stepOptions = stepOptions;
        this.logger = logger;
        this.tempSteps = [];
        this.currentStepIndex = -2;
        this.stepHasBeenModified = new Subject();
    }
    /**
     * @private
     * @return {?}
     */
    getFirstStepIndex() {
        /** @type {?} */
        const firstStep = this.stepOptions.getFirstStep();
        /** @type {?} */
        const stepIds = this.stepOptions.getStepsOrder();
        /** @type {?} */
        let index = stepIds.indexOf(firstStep);
        if (index < 0) {
            index = 0;
            if (firstStep !== undefined)
                this.logger.warn(`The step ${firstStep} does not exist. Check in your step list if it's present.`);
        }
        return index;
    }
    /**
     * @return {?}
     */
    init() {
        this.logger.info('Initializing the steps array.');
        this.steps = [];
        this.currentStepIndex = this.getFirstStepIndex() - 1;
        /** @type {?} */
        let stepIds = this.stepOptions.getStepsOrder();
        stepIds.forEach((/**
         * @param {?} stepId
         * @return {?}
         */
        stepId => this.steps.push({ id: stepId, step: null })));
    }
    /**
     * @param {?} stepToAdd
     * @return {?}
     */
    addStep(stepToAdd) {
        /** @type {?} */
        let stepExist = this.tempSteps.filter((/**
         * @param {?} step
         * @return {?}
         */
        step => step.name === stepToAdd.name)).length > 0;
        if (!stepExist) {
            this.logger.info(`Adding step ${stepToAdd.name} to the steps list.`);
            this.tempSteps.push(stepToAdd);
        }
        else {
            /** @type {?} */
            let stepIndexToReplace = this.tempSteps.findIndex((/**
             * @param {?} step
             * @return {?}
             */
            step => step.name === stepToAdd.name));
            this.tempSteps[stepIndexToReplace] = stepToAdd;
        }
    }
    /**
     * @param {?} action
     * @return {?}
     */
    get(action) {
        if (action === StepActionType.NEXT)
            this.currentStepIndex++;
        else
            this.currentStepIndex--;
        if (this.currentStepIndex < 0 || this.currentStepIndex >= this.steps.length)
            throw new JoyrideStepOutOfRange('The first or last step of the tour cannot be found!');
        /** @type {?} */
        const stepName = this.getStepName(this.steps[this.currentStepIndex].id);
        /** @type {?} */
        const index = this.tempSteps.findIndex((/**
         * @param {?} step
         * @return {?}
         */
        step => step.name === stepName));
        /** @type {?} */
        let stepFound = this.tempSteps[index];
        this.steps[this.currentStepIndex].step = stepFound;
        if (stepFound == null) {
            this.logger.warn(`Step ${this.steps[this.currentStepIndex].id} not found in the DOM. Check if it's hidden by *ngIf directive.`);
        }
        return stepFound;
    }
    /**
     * @param {?} action
     * @return {?}
     */
    getStepRoute(action) {
        /** @type {?} */
        let stepID;
        if (action === StepActionType.NEXT) {
            stepID = this.steps[this.currentStepIndex + 1] ? this.steps[this.currentStepIndex + 1].id : null;
        }
        else {
            stepID = this.steps[this.currentStepIndex - 1] ? this.steps[this.currentStepIndex - 1].id : null;
        }
        /** @type {?} */
        let stepRoute = stepID && stepID.includes(ROUTE_SEPARATOR) ? stepID.split(ROUTE_SEPARATOR)[1] : '';
        return stepRoute;
    }
    /**
     * @param {?} stepName
     * @param {?} position
     * @return {?}
     */
    updatePosition(stepName, position) {
        /** @type {?} */
        let index = this.getStepIndex(stepName);
        if (this.steps[index].step) {
            this.steps[index].step.position = position;
            this.stepHasBeenModified.next(this.steps[index].step);
        }
        else {
            this.logger.warn(`Trying to modify the position of ${stepName} to ${position}. Step not found!Is this step located in a different route?`);
        }
    }
    /**
     * @param {?} stepName
     * @return {?}
     */
    getStepNumber(stepName) {
        return this.getStepIndex(stepName) + 1;
    }
    /**
     * @return {?}
     */
    getStepsCount() {
        /** @type {?} */
        let stepsOrder = this.stepOptions.getStepsOrder();
        return stepsOrder.length;
    }
    /**
     * @private
     * @param {?} stepName
     * @return {?}
     */
    getStepIndex(stepName) {
        /** @type {?} */
        const index = this.steps
            .map((/**
         * @param {?} step
         * @return {?}
         */
        step => (step.id.includes(ROUTE_SEPARATOR) ? step.id.split(ROUTE_SEPARATOR)[0] : step.id)))
            .findIndex((/**
         * @param {?} name
         * @return {?}
         */
        name => stepName === name));
        if (index === -1)
            throw new JoyrideError(`The step with name: ${stepName} does not exist in the step list.`);
        return index;
    }
    /**
     * @private
     * @param {?} stepID
     * @return {?}
     */
    getStepName(stepID) {
        /** @type {?} */
        let stepName = stepID && stepID.includes(ROUTE_SEPARATOR) ? stepID.split(ROUTE_SEPARATOR)[0] : stepID;
        return stepName;
    }
}
JoyrideStepsContainerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
JoyrideStepsContainerService.ctorParameters = () => [
    { type: JoyrideOptionsService },
    { type: LoggerService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    JoyrideStepsContainerService.prototype.steps;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepsContainerService.prototype.tempSteps;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepsContainerService.prototype.currentStepIndex;
    /** @type {?} */
    JoyrideStepsContainerService.prototype.stepHasBeenModified;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepsContainerService.prototype.stepOptions;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepsContainerService.prototype.logger;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/dom.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DomRefService {
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        this.platformId = platformId;
        this.fakeDocument = (/** @type {?} */ ({ body: {}, documentElement: {} }));
        this.fakeWindow = (/** @type {?} */ ({ document: this.fakeDocument, navigator: {} }));
    }
    /**
     * @return {?}
     */
    getNativeWindow() {
        if (isPlatformBrowser(this.platformId))
            return window;
        else
            return this.fakeWindow;
    }
    /**
     * @return {?}
     */
    getNativeDocument() {
        if (isPlatformBrowser(this.platformId))
            return document;
        else
            return this.fakeDocument;
    }
}
DomRefService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DomRefService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    DomRefService.prototype.fakeDocument;
    /**
     * @type {?}
     * @private
     */
    DomRefService.prototype.fakeWindow;
    /**
     * @type {?}
     * @private
     */
    DomRefService.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/templates.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TemplatesService {
    /**
     * @param {?} template
     * @return {?}
     */
    setPrevButton(template) {
        this._prevButton = template;
    }
    /**
     * @return {?}
     */
    getPrevButton() {
        return this._prevButton;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    setNextButton(template) {
        this._nextButton = template;
    }
    /**
     * @return {?}
     */
    getNextButton() {
        return this._nextButton;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    setDoneButton(template) {
        this._doneButton = template;
    }
    /**
     * @return {?}
     */
    getDoneButton() {
        return this._doneButton;
    }
    /**
     * @param {?} template
     * @return {?}
     */
    setCounter(template) {
        this._counter = template;
    }
    /**
     * @return {?}
     */
    getCounter() {
        return this._counter;
    }
}
TemplatesService.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    TemplatesService.prototype._prevButton;
    /**
     * @type {?}
     * @private
     */
    TemplatesService.prototype._nextButton;
    /**
     * @type {?}
     * @private
     */
    TemplatesService.prototype._doneButton;
    /**
     * @type {?}
     * @private
     */
    TemplatesService.prototype._counter;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/joyride.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NO_POSITION = 'NO_POSITION';
class JoyrideDirective {
    /**
     * @param {?} joyrideStepsContainer
     * @param {?} viewContainerRef
     * @param {?} domService
     * @param {?} router
     * @param {?} templateService
     * @param {?} platformId
     */
    constructor(joyrideStepsContainer, viewContainerRef, domService, router, templateService, platformId) {
        this.joyrideStepsContainer = joyrideStepsContainer;
        this.viewContainerRef = viewContainerRef;
        this.domService = domService;
        this.router = router;
        this.templateService = templateService;
        this.platformId = platformId;
        this.stepPosition = NO_POSITION;
        this.prev = new EventEmitter();
        this.next = new EventEmitter();
        this.done = new EventEmitter();
        this.subscriptions = [];
        this.windowRef = this.domService.getNativeWindow();
        this.step = new JoyrideStep();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!isPlatformBrowser(this.platformId))
            return;
        if (this.prevTemplate)
            this.templateService.setPrevButton(this.prevTemplate);
        if (this.nextTemplate)
            this.templateService.setNextButton(this.nextTemplate);
        if (this.doneTemplate)
            this.templateService.setDoneButton(this.doneTemplate);
        if (this.counterTemplate)
            this.templateService.setCounter(this.counterTemplate);
        this.step.position = this.stepPosition;
        this.step.targetViewContainer = this.viewContainerRef;
        this.setAsyncFields(this.step);
        this.step.stepContent = this.stepContent;
        this.step.stepContentParams = this.stepContentParams;
        this.step.nextClicked = this.next;
        this.step.prevCliked = this.prev;
        this.step.tourDone = this.done;
        if (!this.name)
            throw new JoyrideError("All the steps should have the 'joyrideStep' property set with a custom name.");
        this.step.name = this.name;
        this.step.route = this.router.url.substr(0, 1) === '/' ? this.router.url.substr(1) : this.router.url;
        this.step.transformCssStyle = this.windowRef.getComputedStyle(this.viewContainerRef.element.nativeElement).transform;
        this.step.isElementOrAncestorFixed =
            this.isElementFixed(this.viewContainerRef.element) ||
                this.isAncestorsFixed(this.viewContainerRef.element.nativeElement.parentElement);
        this.joyrideStepsContainer.addStep(this.step);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['title'] || changes['text']) {
            this.setAsyncFields(this.step);
        }
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    isElementFixed(element) {
        return this.windowRef.getComputedStyle(element.nativeElement).position === 'fixed';
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    setAsyncFields(step) {
        if (this.title instanceof Observable) {
            this.subscriptions.push(this.title.subscribe((/**
             * @param {?} title
             * @return {?}
             */
            title => {
                step.title.next(title);
            })));
        }
        else {
            step.title.next(this.title);
        }
        if (this.text instanceof Observable) {
            this.subscriptions.push(this.text.subscribe((/**
             * @param {?} text
             * @return {?}
             */
            text => {
                step.text.next(text);
            })));
        }
        else {
            step.text.next(this.text);
        }
    }
    /**
     * @private
     * @param {?} nativeElement
     * @return {?}
     */
    isAncestorsFixed(nativeElement) {
        if (!nativeElement || !nativeElement.parentElement)
            return false;
        /** @type {?} */
        let isElementFixed = this.windowRef.getComputedStyle(nativeElement.parentElement).position === 'fixed';
        if (nativeElement.nodeName === 'BODY') {
            return isElementFixed;
        }
        if (isElementFixed)
            return true;
        else
            return this.isAncestorsFixed(nativeElement.parentElement);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} sub
         * @return {?}
         */
        sub => {
            sub.unsubscribe();
        }));
    }
}
JoyrideDirective.decorators = [
    { type: Directive, args: [{
                selector: 'joyrideStep, [joyrideStep]'
            },] }
];
/** @nocollapse */
JoyrideDirective.ctorParameters = () => [
    { type: JoyrideStepsContainerService },
    { type: ViewContainerRef },
    { type: DomRefService },
    { type: Router },
    { type: TemplatesService },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
JoyrideDirective.propDecorators = {
    name: [{ type: Input, args: ['joyrideStep',] }],
    nextStep: [{ type: Input }],
    title: [{ type: Input }],
    text: [{ type: Input }],
    stepPosition: [{ type: Input }],
    stepContent: [{ type: Input }],
    stepContentParams: [{ type: Input }],
    prevTemplate: [{ type: Input }],
    nextTemplate: [{ type: Input }],
    doneTemplate: [{ type: Input }],
    counterTemplate: [{ type: Input }],
    prev: [{ type: Output }],
    next: [{ type: Output }],
    done: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    JoyrideDirective.prototype.name;
    /** @type {?} */
    JoyrideDirective.prototype.nextStep;
    /** @type {?} */
    JoyrideDirective.prototype.title;
    /** @type {?} */
    JoyrideDirective.prototype.text;
    /** @type {?} */
    JoyrideDirective.prototype.stepPosition;
    /** @type {?} */
    JoyrideDirective.prototype.stepContent;
    /** @type {?} */
    JoyrideDirective.prototype.stepContentParams;
    /** @type {?} */
    JoyrideDirective.prototype.prevTemplate;
    /** @type {?} */
    JoyrideDirective.prototype.nextTemplate;
    /** @type {?} */
    JoyrideDirective.prototype.doneTemplate;
    /** @type {?} */
    JoyrideDirective.prototype.counterTemplate;
    /** @type {?} */
    JoyrideDirective.prototype.prev;
    /** @type {?} */
    JoyrideDirective.prototype.next;
    /** @type {?} */
    JoyrideDirective.prototype.done;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.windowRef;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.step;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.subscriptions;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.joyrideStepsContainer;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.domService;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.router;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.templateService;
    /**
     * @type {?}
     * @private
     */
    JoyrideDirective.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/document.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function IDocumentService() { }
if (false) {
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.getElementFixedTop = function (elementRef) { };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.getElementFixedLeft = function (elementRef) { };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.getElementAbsoluteTop = function (elementRef) { };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.getElementAbsoluteLeft = function (elementRef) { };
    /**
     * @return {?}
     */
    IDocumentService.prototype.setDocumentHeight = function () { };
    /**
     * @return {?}
     */
    IDocumentService.prototype.getDocumentHeight = function () { };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.isParentScrollable = function (elementRef) { };
    /**
     * @param {?} elementRef
     * @param {?} isElementFixed
     * @param {?} keywordToDiscard
     * @return {?}
     */
    IDocumentService.prototype.isElementBeyondOthers = function (elementRef, isElementFixed, keywordToDiscard) { };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.scrollToTheTop = function (elementRef) { };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    IDocumentService.prototype.scrollToTheBottom = function (elementRef) { };
}
class DocumentService {
    /**
     * @param {?} DOMService
     */
    constructor(DOMService) {
        this.DOMService = DOMService;
        this.setDocumentHeight();
        if (!document.elementsFromPoint) {
            // IE 11 - Edge browsers
            document.elementsFromPoint = this.elementsFromPoint.bind(this);
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getElementFixedTop(elementRef) {
        return elementRef.nativeElement.getBoundingClientRect().top;
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getElementFixedLeft(elementRef) {
        return elementRef.nativeElement.getBoundingClientRect().left;
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getElementAbsoluteTop(elementRef) {
        /** @type {?} */
        const scrollOffsets = this.getScrollOffsets();
        return (elementRef.nativeElement.getBoundingClientRect().top +
            scrollOffsets.y);
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getElementAbsoluteLeft(elementRef) {
        /** @type {?} */
        const scrollOffsets = this.getScrollOffsets();
        return (elementRef.nativeElement.getBoundingClientRect().left +
            scrollOffsets.x);
    }
    /**
     * @return {?}
     */
    setDocumentHeight() {
        this.documentHeight = this.calculateDocumentHeight();
    }
    /**
     * @return {?}
     */
    getDocumentHeight() {
        return this.documentHeight;
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    isParentScrollable(elementRef) {
        return (this.getFirstScrollableParent(elementRef.nativeElement) !==
            this.DOMService.getNativeDocument().body);
    }
    /**
     * @param {?} elementRef
     * @param {?} isElementFixed
     * @param {?} keywordToDiscard
     * @return {?}
     */
    isElementBeyondOthers(elementRef, isElementFixed, keywordToDiscard) {
        /** @type {?} */
        const x1 = isElementFixed
            ? this.getElementFixedLeft(elementRef)
            : this.getElementAbsoluteLeft(elementRef);
        /** @type {?} */
        const y1 = isElementFixed
            ? this.getElementFixedTop(elementRef)
            : this.getElementAbsoluteTop(elementRef);
        /** @type {?} */
        const x2 = x1 + elementRef.nativeElement.getBoundingClientRect().width - 1;
        /** @type {?} */
        const y2 = y1 + elementRef.nativeElement.getBoundingClientRect().height - 1;
        /** @type {?} */
        const elements1 = this.DOMService.getNativeDocument().elementsFromPoint(x1, y1);
        /** @type {?} */
        const elements2 = this.DOMService.getNativeDocument().elementsFromPoint(x2, y2);
        if (elements1.length === 0 && elements2.length === 0)
            return 1;
        if (this.getFirstElementWithoutKeyword(elements1, keywordToDiscard) !==
            elementRef.nativeElement ||
            this.getFirstElementWithoutKeyword(elements2, keywordToDiscard) !==
                elementRef.nativeElement) {
            return 2;
        }
        return 3;
    }
    /**
     * @param {?} elementRef
     * @param {?} isElementFixed
     * @return {?}
     */
    scrollIntoView(elementRef, isElementFixed) {
        /** @type {?} */
        const firstScrollableParent = this.getFirstScrollableParent(elementRef.nativeElement);
        /** @type {?} */
        const top = isElementFixed
            ? this.getElementFixedTop(elementRef)
            : this.getElementAbsoluteTop(elementRef);
        if (firstScrollableParent !== this.DOMService.getNativeDocument().body) {
            if (firstScrollableParent.scrollTo) {
                firstScrollableParent.scrollTo(0, top - 150);
            }
            else {
                // IE 11 - Edge browsers
                firstScrollableParent.scrollTop = top - 150;
            }
        }
        else {
            this.DOMService.getNativeWindow().scrollTo(0, top - 150);
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    scrollToTheTop(elementRef) {
        /** @type {?} */
        const firstScrollableParent = this.getFirstScrollableParent(elementRef.nativeElement);
        if (firstScrollableParent !== this.DOMService.getNativeDocument().body) {
            if (firstScrollableParent.scrollTo) {
                firstScrollableParent.scrollTo(0, 0);
            }
            else {
                // IE 11 - Edge browsers
                firstScrollableParent.scrollTop = 0;
            }
        }
        else {
            this.DOMService.getNativeWindow().scrollTo(0, 0);
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    scrollToTheBottom(elementRef) {
        /** @type {?} */
        const firstScrollableParent = this.getFirstScrollableParent(elementRef.nativeElement);
        if (firstScrollableParent !== this.DOMService.getNativeDocument().body) {
            if (firstScrollableParent.scrollTo) {
                firstScrollableParent.scrollTo(0, this.DOMService.getNativeDocument().body.scrollHeight);
            }
            else {
                // IE 11 - Edge browsers
                firstScrollableParent.scrollTop =
                    firstScrollableParent.scrollHeight -
                        firstScrollableParent.clientHeight;
            }
        }
        else {
            this.DOMService.getNativeWindow().scrollTo(0, this.DOMService.getNativeDocument().body.scrollHeight);
        }
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getFirstScrollableParent(node) {
        /** @type {?} */
        const regex = /(auto|scroll|overlay)/;
        /** @type {?} */
        const style = (/**
         * @param {?} node
         * @param {?} prop
         * @return {?}
         */
        (node, prop) => this.DOMService.getNativeWindow()
            .getComputedStyle(node, null)
            .getPropertyValue(prop));
        /** @type {?} */
        const scroll = (/**
         * @param {?} node
         * @return {?}
         */
        (node) => regex.test(style(node, 'overflow') +
            style(node, 'overflow-y') +
            style(node, 'overflow-x')));
        /** @type {?} */
        const scrollparent = (/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            return !node || node === this.DOMService.getNativeDocument().body
                ? this.DOMService.getNativeDocument().body
                : scroll(node)
                    ? node
                    : scrollparent(node.parentNode);
        });
        return scrollparent(node);
    }
    /**
     * @private
     * @return {?}
     */
    calculateDocumentHeight() {
        /** @type {?} */
        const documentRef = this.DOMService.getNativeDocument();
        return Math.max(documentRef.body.scrollHeight, documentRef.documentElement.scrollHeight, documentRef.body.offsetHeight, documentRef.documentElement.offsetHeight, documentRef.body.clientHeight, documentRef.documentElement.clientHeight);
    }
    /**
     * @private
     * @return {?}
     */
    getScrollOffsets() {
        /** @type {?} */
        const winReference = this.DOMService.getNativeWindow();
        /** @type {?} */
        const docReference = this.DOMService.getNativeDocument();
        // This works for all browsers except IE versions 8 and before
        if (winReference.pageXOffset != null)
            return { x: winReference.pageXOffset, y: winReference.pageYOffset };
        // For IE (or any browser) in Standards mode
        if (docReference.compatMode == 'CSS1Compat')
            return {
                x: docReference.documentElement.scrollLeft,
                y: docReference.documentElement.scrollTop
            };
        // For browsers in Quirks mode
        return {
            x: docReference.body.scrollLeft,
            y: docReference.body.scrollTop
        };
    }
    /**
     * @private
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    elementsFromPoint(x, y) {
        /** @type {?} */
        var parents = [];
        /** @type {?} */
        var parent = void 0;
        do {
            /** @type {?} */
            const elem = this.DOMService.getNativeDocument().elementFromPoint(x, y);
            if (elem && parent !== elem) {
                parent = elem;
                parents.push(parent);
                parent.style.pointerEvents = 'none';
            }
            else {
                parent = false;
            }
        } while (parent);
        parents.forEach((/**
         * @param {?} parent
         * @return {?}
         */
        function (parent) {
            return (parent.style.pointerEvents = 'all');
        }));
        return parents;
    }
    /**
     * @private
     * @param {?} elements
     * @param {?} keyword
     * @return {?}
     */
    getFirstElementWithoutKeyword(elements, keyword) {
        while (elements[0] &&
            elements[0].classList.toString().includes(keyword)) {
            elements.shift();
        }
        return elements[0];
    }
}
DocumentService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DocumentService.ctorParameters = () => [
    { type: DomRefService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    DocumentService.prototype.documentHeight;
    /**
     * @type {?}
     * @private
     */
    DocumentService.prototype.DOMService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/joyride-backdrop.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideBackdropService {
    /**
     * @param {?} documentService
     * @param {?} optionsService
     * @param {?} rendererFactory
     */
    constructor(documentService, optionsService, rendererFactory) {
        this.documentService = documentService;
        this.optionsService = optionsService;
        this.rendererFactory = rendererFactory;
        this.lastXScroll = 0;
        this.lastYScroll = 0;
        this.setRenderer();
    }
    /**
     * @private
     * @return {?}
     */
    setRenderer() {
        this.renderer = this.rendererFactory.createRenderer(null, null);
    }
    /**
     * @param {?} step
     * @return {?}
     */
    draw(step) {
        this.elementRef = step.targetViewContainer;
        this.targetAbsoluteTop = this.getTargetTotalTop(step);
        this.targetAbsoluteLeft = this.getTargetTotalLeft(step);
        this.currentBackdropContainer = this.renderer.createElement('div');
        this.renderer.addClass(this.currentBackdropContainer, 'backdrop-container');
        this.renderer.setStyle(this.currentBackdropContainer, 'position', 'fixed');
        this.renderer.setStyle(this.currentBackdropContainer, 'top', '0px');
        this.renderer.setStyle(this.currentBackdropContainer, 'left', '0px');
        this.renderer.setStyle(this.currentBackdropContainer, 'width', '100%');
        this.renderer.setStyle(this.currentBackdropContainer, 'height', '100%');
        this.renderer.setStyle(this.currentBackdropContainer, 'z-index', '1000');
        this.renderer.setAttribute(this.currentBackdropContainer, 'id', 'backdrop-' + step.name);
        this.backdropContent = this.renderer.createElement('div');
        this.renderer.addClass(this.backdropContent, 'backdrop-content');
        this.renderer.setStyle(this.backdropContent, 'position', 'relative');
        this.renderer.setStyle(this.backdropContent, 'height', '100%');
        this.renderer.setStyle(this.backdropContent, 'display', 'flex');
        this.renderer.setStyle(this.backdropContent, 'flex-direction', 'column');
        this.renderer.appendChild(this.currentBackdropContainer, this.backdropContent);
        this.backdropTop = this.renderer.createElement('div');
        this.renderer.addClass(this.backdropTop, 'joyride-backdrop');
        this.renderer.addClass(this.backdropTop, 'backdrop-top');
        this.renderer.setStyle(this.backdropTop, 'width', '100%');
        this.renderer.setStyle(this.backdropTop, 'height', this.targetAbsoluteTop - this.lastYScroll + 'px');
        this.renderer.setStyle(this.backdropTop, 'flex-shrink', '0');
        this.renderer.setStyle(this.backdropTop, 'background-color', `rgba(${this.optionsService.getBackdropColor()}, 0.7)`);
        this.renderer.appendChild(this.backdropContent, this.backdropTop);
        this.backdropMiddleContainer = this.renderer.createElement('div');
        this.renderer.addClass(this.backdropMiddleContainer, 'backdrop-middle-container');
        this.renderer.setStyle(this.backdropMiddleContainer, 'height', this.elementRef.element.nativeElement.offsetHeight + 'px');
        this.renderer.setStyle(this.backdropMiddleContainer, 'width', '100%');
        this.renderer.setStyle(this.backdropMiddleContainer, 'flex-shrink', '0');
        this.renderer.appendChild(this.backdropContent, this.backdropMiddleContainer);
        this.backdropMiddleContent = this.renderer.createElement('div');
        this.renderer.addClass(this.backdropMiddleContent, 'backdrop-middle-content');
        this.renderer.setStyle(this.backdropMiddleContent, 'display', 'flex');
        this.renderer.setStyle(this.backdropMiddleContent, 'width', '100%');
        this.renderer.setStyle(this.backdropMiddleContent, 'height', '100%');
        this.renderer.appendChild(this.backdropMiddleContainer, this.backdropMiddleContent);
        this.leftBackdrop = this.renderer.createElement('div');
        this.renderer.addClass(this.leftBackdrop, 'joyride-backdrop');
        this.renderer.addClass(this.leftBackdrop, 'backdrop-left');
        this.renderer.setStyle(this.leftBackdrop, 'flex-shrink', '0');
        this.renderer.setStyle(this.leftBackdrop, 'width', this.targetAbsoluteLeft - this.lastXScroll + 'px');
        this.renderer.setStyle(this.leftBackdrop, 'background-color', `rgba(${this.optionsService.getBackdropColor()}, 0.7)`);
        this.renderer.appendChild(this.backdropMiddleContent, this.leftBackdrop);
        this.targetBackdrop = this.renderer.createElement('div');
        this.renderer.addClass(this.targetBackdrop, 'backdrop-target');
        this.renderer.setStyle(this.targetBackdrop, 'flex-shrink', '0');
        this.renderer.setStyle(this.targetBackdrop, 'width', this.elementRef.element.nativeElement.offsetWidth + 'px');
        this.renderer.appendChild(this.backdropMiddleContent, this.targetBackdrop);
        this.rightBackdrop = this.renderer.createElement('div');
        this.renderer.addClass(this.rightBackdrop, 'joyride-backdrop');
        this.renderer.addClass(this.rightBackdrop, 'backdrop-right');
        this.renderer.setStyle(this.rightBackdrop, 'width', '100%');
        this.renderer.setStyle(this.rightBackdrop, 'background-color', `rgba(${this.optionsService.getBackdropColor()}, 0.7)`);
        this.renderer.appendChild(this.backdropMiddleContent, this.rightBackdrop);
        this.backdropBottom = this.renderer.createElement('div');
        this.renderer.addClass(this.backdropBottom, 'joyride-backdrop');
        this.renderer.addClass(this.backdropBottom, 'backdrop-bottom');
        this.renderer.setStyle(this.backdropBottom, 'width', '100%');
        this.renderer.setStyle(this.backdropBottom, 'height', '100%');
        this.renderer.setStyle(this.backdropBottom, 'background-color', `rgba(${this.optionsService.getBackdropColor()}, 0.7)`);
        this.renderer.appendChild(this.backdropContent, this.backdropBottom);
        this.removeLastBackdrop();
        this.drawCurrentBackdrop();
        this.lastBackdropContainer = this.currentBackdropContainer;
    }
    /**
     * @return {?}
     */
    remove() {
        this.removeLastBackdrop();
    }
    /**
     * @param {?} step
     * @return {?}
     */
    redrawTarget(step) {
        this.targetAbsoluteLeft = this.getTargetTotalLeft(step);
        this.targetAbsoluteTop = this.getTargetTotalTop(step);
        this.handleVerticalScroll(step);
        this.handleHorizontalScroll(step);
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    getTargetTotalTop(step) {
        /** @type {?} */
        let targetVC = step.targetViewContainer;
        return step.isElementOrAncestorFixed
            ? this.documentService.getElementFixedTop(targetVC.element)
            : this.documentService.getElementAbsoluteTop(targetVC.element);
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    getTargetTotalLeft(step) {
        /** @type {?} */
        let targetVC = step.targetViewContainer;
        return step.isElementOrAncestorFixed
            ? this.documentService.getElementFixedLeft(targetVC.element)
            : this.documentService.getElementAbsoluteLeft(targetVC.element);
    }
    /**
     * @param {?} step
     * @param {?} scroll
     * @return {?}
     */
    redraw(step, scroll) {
        if (this.lastYScroll !== scroll.scrollY) {
            this.lastYScroll = scroll.scrollY;
            if (this.elementRef) {
                this.handleVerticalScroll(step);
            }
        }
        if (this.lastXScroll !== scroll.scrollX) {
            this.lastXScroll = scroll.scrollX;
            if (this.elementRef) {
                this.handleHorizontalScroll(step);
            }
        }
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    handleHorizontalScroll(step) {
        /** @type {?} */
        let newBackdropLeftWidth = step.isElementOrAncestorFixed ? this.targetAbsoluteLeft : this.targetAbsoluteLeft - this.lastXScroll;
        if (newBackdropLeftWidth >= 0) {
            this.renderer.setStyle(this.leftBackdrop, 'width', newBackdropLeftWidth + 'px');
            this.renderer.setStyle(this.targetBackdrop, 'width', this.elementRef.element.nativeElement.offsetWidth + 'px');
        }
        else {
            this.handleTargetPartialWidth(newBackdropLeftWidth);
        }
    }
    /**
     * @private
     * @param {?} newBackdropLeftWidth
     * @return {?}
     */
    handleTargetPartialWidth(newBackdropLeftWidth) {
        this.renderer.setStyle(this.leftBackdrop, 'width', 0 + 'px');
        /** @type {?} */
        let visibleTargetWidth = this.elementRef.element.nativeElement.offsetWidth + newBackdropLeftWidth;
        if (visibleTargetWidth >= 0) {
            this.renderer.setStyle(this.targetBackdrop, 'width', visibleTargetWidth + 'px');
        }
        else {
            this.renderer.setStyle(this.targetBackdrop, 'width', 0 + 'px');
        }
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    handleVerticalScroll(step) {
        /** @type {?} */
        let newBackdropTopHeight = step.isElementOrAncestorFixed ? this.targetAbsoluteTop : this.targetAbsoluteTop - this.lastYScroll;
        if (newBackdropTopHeight >= 0) {
            this.renderer.setStyle(this.backdropTop, 'height', newBackdropTopHeight + 'px');
            this.renderer.setStyle(this.backdropMiddleContainer, 'height', this.elementRef.element.nativeElement.offsetHeight + 'px');
        }
        else {
            this.handleTargetPartialHeight(newBackdropTopHeight);
        }
    }
    /**
     * @private
     * @param {?} newBackdropTopHeight
     * @return {?}
     */
    handleTargetPartialHeight(newBackdropTopHeight) {
        this.renderer.setStyle(this.backdropTop, 'height', 0 + 'px');
        /** @type {?} */
        let visibleTargetHeight = this.elementRef.element.nativeElement.offsetHeight + newBackdropTopHeight;
        if (visibleTargetHeight >= 0) {
            this.renderer.setStyle(this.backdropMiddleContainer, 'height', visibleTargetHeight + 'px');
        }
        else {
            this.renderer.setStyle(this.backdropMiddleContainer, 'height', 0 + 'px');
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeLastBackdrop() {
        if (this.lastBackdropContainer) {
            this.renderer.removeChild(document.body, this.lastBackdropContainer);
            this.lastBackdropContainer = undefined;
        }
    }
    /**
     * @private
     * @return {?}
     */
    drawCurrentBackdrop() {
        this.renderer.appendChild(document.body, this.currentBackdropContainer);
    }
}
JoyrideBackdropService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
JoyrideBackdropService.ctorParameters = () => [
    { type: DocumentService },
    { type: JoyrideOptionsService },
    { type: RendererFactory2 }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.currentBackdropContainer;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.lastBackdropContainer;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.backdropContent;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.backdropTop;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.backdropBottom;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.backdropMiddleContainer;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.backdropMiddleContent;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.leftBackdrop;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.targetBackdrop;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.rightBackdrop;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.targetAbsoluteTop;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.targetAbsoluteLeft;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.lastXScroll;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.lastYScroll;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.documentService;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.optionsService;
    /**
     * @type {?}
     * @private
     */
    JoyrideBackdropService.prototype.rendererFactory;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/event-listener.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Scroll {
}
if (false) {
    /** @type {?} */
    Scroll.prototype.scrollX;
    /** @type {?} */
    Scroll.prototype.scrollY;
}
class EventListenerService {
    /**
     * @param {?} rendererFactory
     * @param {?} DOMService
     */
    constructor(rendererFactory, DOMService) {
        this.rendererFactory = rendererFactory;
        this.DOMService = DOMService;
        this.scrollEvent = new Subject();
        this.resizeEvent = new Subject();
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * @return {?}
     */
    startListeningScrollEvents() {
        this.scrollUnlisten = this.renderer.listen('document', 'scroll', (/**
         * @param {?} evt
         * @return {?}
         */
        evt => {
            this.scrollEvent.next({
                scrollX: this.DOMService.getNativeWindow().pageXOffset,
                scrollY: this.DOMService.getNativeWindow().pageYOffset
            });
        }));
    }
    /**
     * @return {?}
     */
    startListeningResizeEvents() {
        this.resizeUnlisten = this.renderer.listen('window', 'resize', (/**
         * @param {?} evt
         * @return {?}
         */
        evt => {
            this.resizeEvent.next(evt);
        }));
    }
    /**
     * @return {?}
     */
    stopListeningScrollEvents() {
        this.scrollUnlisten();
    }
    /**
     * @return {?}
     */
    stopListeningResizeEvents() {
        this.resizeUnlisten();
    }
}
EventListenerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EventListenerService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: DomRefService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    EventListenerService.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    EventListenerService.prototype.scrollUnlisten;
    /**
     * @type {?}
     * @private
     */
    EventListenerService.prototype.resizeUnlisten;
    /** @type {?} */
    EventListenerService.prototype.scrollEvent;
    /** @type {?} */
    EventListenerService.prototype.resizeEvent;
    /**
     * @type {?}
     * @private
     */
    EventListenerService.prototype.rendererFactory;
    /**
     * @type {?}
     * @private
     */
    EventListenerService.prototype.DOMService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/step/joyride-step.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const STEP_MIN_WIDTH = 200;
/** @type {?} */
const STEP_MAX_WIDTH = 400;
/** @type {?} */
const CUSTOM_STEP_MAX_WIDTH_VW = 90;
/** @type {?} */
const STEP_HEIGHT = 200;
/** @type {?} */
const ASPECT_RATIO = 1.212;
/** @type {?} */
const DEFAULT_DISTANCE_FROM_MARGIN_TOP = 2;
/** @type {?} */
const DEFAULT_DISTANCE_FROM_MARGIN_LEFT = 2;
/** @type {?} */
const DEFAULT_DISTANCE_FROM_MARGIN_BOTTOM = 5;
/** @type {?} */
const DEFAULT_DISTANCE_FROM_MARGIN_RIGHT = 5;
class JoyrideStepComponent {
    /**
     * @param {?} injector
     * @param {?} stepsContainerService
     * @param {?} eventListenerService
     * @param {?} documentService
     * @param {?} renderer
     * @param {?} logger
     * @param {?} optionsService
     * @param {?} templateService
     */
    constructor(injector, stepsContainerService, eventListenerService, documentService, renderer, logger, optionsService, templateService) {
        this.injector = injector;
        this.stepsContainerService = stepsContainerService;
        this.eventListenerService = eventListenerService;
        this.documentService = documentService;
        this.renderer = renderer;
        this.logger = logger;
        this.optionsService = optionsService;
        this.templateService = templateService;
        this.stepWidth = STEP_MIN_WIDTH;
        this.stepHeight = STEP_HEIGHT;
        this.showArrow = true;
        this.arrowSize = ARROW_SIZE;
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Need to Inject here otherwise you will obtain a circular dependency
        this.joyrideStepService = this.injector.get(JoyrideStepService);
        this.documentHeight = this.documentService.getDocumentHeight();
        this.subscriptions.push(this.subscribeToResizeEvents());
        this.title = this.step.title.asObservable();
        this.text = this.step.text.asObservable();
        this.setCustomTemplates();
        this.setCustomTexts();
        this.counter = this.getCounter();
        this.isCounterVisible = this.optionsService.isCounterVisible();
        this.isPrevButtonVisible = this.optionsService.isPrevButtonVisible();
        this.themeColor = this.optionsService.getThemeColor();
        if (this.text)
            this.text.subscribe((/**
             * @param {?} val
             * @return {?}
             */
            val => this.checkRedraw(val)));
        if (this.title)
            this.title.subscribe((/**
             * @param {?} val
             * @return {?}
             */
            val => this.checkRedraw(val)));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.isCustomized()) {
            this.renderer.setStyle(this.stepContainer.nativeElement, 'max-width', CUSTOM_STEP_MAX_WIDTH_VW + 'vw');
            this.updateStepDimensions();
        }
        else {
            this.renderer.setStyle(this.stepContainer.nativeElement, 'max-width', STEP_MAX_WIDTH + 'px');
            /** @type {?} */
            let dimensions = this.getDimensionsByAspectRatio(this.stepContainer.nativeElement.clientWidth, this.stepContainer.nativeElement.clientHeight, ASPECT_RATIO);
            dimensions = this.adjustDimensions(dimensions.width, dimensions.height);
            this.stepWidth = dimensions.width;
            this.stepHeight = dimensions.height;
            this.renderer.setStyle(this.stepContainer.nativeElement, 'width', this.stepWidth + 'px');
            this.renderer.setStyle(this.stepContainer.nativeElement, 'height', this.stepHeight + 'px');
        }
        this.drawStep();
    }
    /**
     * @private
     * @param {?} val
     * @return {?}
     */
    checkRedraw(val) {
        if (val != null) {
            // Need to wait that the change is rendered before redrawing
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.redrawStep();
            }), 2);
        }
    }
    /**
     * @private
     * @return {?}
     */
    isCustomized() {
        return (this.step.stepContent ||
            this.templateService.getCounter() ||
            this.templateService.getPrevButton() ||
            this.templateService.getNextButton() ||
            this.templateService.getDoneButton());
    }
    /**
     * @private
     * @return {?}
     */
    setCustomTexts() {
        /** @type {?} */
        const customeTexts = this.optionsService.getCustomTexts();
        this.prevText = customeTexts.prev;
        this.nextText = customeTexts.next;
        this.doneText = customeTexts.done;
    }
    /**
     * @private
     * @return {?}
     */
    drawStep() {
        /** @type {?} */
        let position = this.step.isElementOrAncestorFixed
            ? 'fixed'
            : 'absolute';
        this.renderer.setStyle(this.stepHolder.nativeElement, 'position', position);
        this.renderer.setStyle(this.stepHolder.nativeElement, 'transform', this.step.transformCssStyle);
        this.targetWidth = this.step.targetViewContainer.element.nativeElement.getBoundingClientRect().width;
        this.targetHeight = this.step.targetViewContainer.element.nativeElement.getBoundingClientRect().height;
        this.targetAbsoluteLeft =
            position === 'fixed'
                ? this.documentService.getElementFixedLeft(this.step.targetViewContainer.element)
                : this.documentService.getElementAbsoluteLeft(this.step.targetViewContainer.element);
        this.targetAbsoluteTop =
            position === 'fixed'
                ? this.documentService.getElementFixedTop(this.step.targetViewContainer.element)
                : this.documentService.getElementAbsoluteTop(this.step.targetViewContainer.element);
        this.setStepStyle();
    }
    /**
     * @private
     * @return {?}
     */
    getCounter() {
        /** @type {?} */
        let stepPosition = this.stepsContainerService.getStepNumber(this.step.name);
        /** @type {?} */
        let numberOfSteps = this.stepsContainerService.getStepsCount();
        this.counterData = { step: stepPosition, total: numberOfSteps };
        return stepPosition + '/' + numberOfSteps;
    }
    /**
     * @private
     * @return {?}
     */
    setCustomTemplates() {
        this.customContent = this.step.stepContent;
        this.ctx = this.step.stepContentParams;
        this.customPrevButton = this.templateService.getPrevButton();
        this.customNextButton = this.templateService.getNextButton();
        this.customDoneButton = this.templateService.getDoneButton();
        this.customCounter = this.templateService.getCounter();
    }
    /**
     * @return {?}
     */
    prev() {
        this.joyrideStepService.prev();
    }
    /**
     * @return {?}
     */
    next() {
        this.joyrideStepService.next();
    }
    /**
     * @return {?}
     */
    close() {
        this.joyrideStepService.close();
    }
    /**
     * @return {?}
     */
    isFirstStep() {
        return this.stepsContainerService.getStepNumber(this.step.name) === 1;
    }
    /**
     * @return {?}
     */
    isLastStep() {
        return (this.stepsContainerService.getStepNumber(this.step.name) ===
            this.stepsContainerService.getStepsCount());
    }
    /**
     * @private
     * @return {?}
     */
    setStepStyle() {
        switch (this.step.position) {
            case 'top': {
                this.setStyleTop();
                break;
            }
            case 'bottom': {
                this.setStyleBottom();
                break;
            }
            case 'right': {
                this.setStyleRight();
                break;
            }
            case 'left': {
                this.setStyleLeft();
                break;
            }
            case 'center': {
                this.setStyleCenter();
                break;
            }
            default: {
                this.setStyleBottom();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    setStyleTop() {
        this.stepsContainerService.updatePosition(this.step.name, 'top');
        this.topPosition =
            this.targetAbsoluteTop - DISTANCE_FROM_TARGET - this.stepHeight;
        this.stepAbsoluteTop =
            this.targetAbsoluteTop - DISTANCE_FROM_TARGET - this.stepHeight;
        this.arrowTopPosition = this.stepHeight;
        this.leftPosition =
            this.targetWidth / 2 - this.stepWidth / 2 + this.targetAbsoluteLeft;
        this.stepAbsoluteLeft =
            this.targetWidth / 2 - this.stepWidth / 2 + this.targetAbsoluteLeft;
        this.arrowLeftPosition = this.stepWidth / 2 - this.arrowSize;
        this.adjustLeftPosition();
        this.adjustRightPosition();
        this.arrowPosition = 'bottom';
        this.autofixTopPosition();
    }
    /**
     * @private
     * @return {?}
     */
    setStyleRight() {
        this.stepsContainerService.updatePosition(this.step.name, 'right');
        this.topPosition =
            this.targetAbsoluteTop +
                this.targetHeight / 2 -
                this.stepHeight / 2;
        this.stepAbsoluteTop =
            this.targetAbsoluteTop +
                this.targetHeight / 2 -
                this.stepHeight / 2;
        this.arrowTopPosition = this.stepHeight / 2 - this.arrowSize;
        this.leftPosition =
            this.targetAbsoluteLeft + this.targetWidth + DISTANCE_FROM_TARGET;
        this.stepAbsoluteLeft =
            this.targetAbsoluteLeft + this.targetWidth + DISTANCE_FROM_TARGET;
        this.arrowLeftPosition = -this.arrowSize;
        this.adjustTopPosition();
        this.adjustBottomPosition();
        this.arrowPosition = 'left';
        this.autofixRightPosition();
    }
    /**
     * @private
     * @return {?}
     */
    setStyleBottom() {
        this.stepsContainerService.updatePosition(this.step.name, 'bottom');
        this.topPosition =
            this.targetAbsoluteTop + this.targetHeight + DISTANCE_FROM_TARGET;
        this.stepAbsoluteTop =
            this.targetAbsoluteTop + this.targetHeight + DISTANCE_FROM_TARGET;
        this.arrowTopPosition = -this.arrowSize;
        this.arrowLeftPosition = this.stepWidth / 2 - this.arrowSize;
        this.leftPosition =
            this.targetWidth / 2 - this.stepWidth / 2 + this.targetAbsoluteLeft;
        this.stepAbsoluteLeft =
            this.targetWidth / 2 - this.stepWidth / 2 + this.targetAbsoluteLeft;
        this.adjustLeftPosition();
        this.adjustRightPosition();
        this.arrowPosition = 'top';
        this.autofixBottomPosition();
    }
    /**
     * @private
     * @return {?}
     */
    setStyleLeft() {
        this.stepsContainerService.updatePosition(this.step.name, 'left');
        this.topPosition =
            this.targetAbsoluteTop +
                this.targetHeight / 2 -
                this.stepHeight / 2;
        this.stepAbsoluteTop =
            this.targetAbsoluteTop +
                this.targetHeight / 2 -
                this.stepHeight / 2;
        this.arrowTopPosition = this.stepHeight / 2 - this.arrowSize;
        this.leftPosition =
            this.targetAbsoluteLeft - this.stepWidth - DISTANCE_FROM_TARGET;
        this.stepAbsoluteLeft =
            this.targetAbsoluteLeft - this.stepWidth - DISTANCE_FROM_TARGET;
        this.arrowLeftPosition = this.stepWidth;
        this.adjustTopPosition();
        this.adjustBottomPosition();
        this.arrowPosition = 'right';
        this.autofixLeftPosition();
    }
    /**
     * @private
     * @return {?}
     */
    setStyleCenter() {
        this.renderer.setStyle(this.stepHolder.nativeElement, 'position', 'fixed');
        this.renderer.setStyle(this.stepHolder.nativeElement, 'top', '50%');
        this.renderer.setStyle(this.stepHolder.nativeElement, 'left', '50%');
        this.updateStepDimensions();
        this.renderer.setStyle(this.stepHolder.nativeElement, 'transform', `translate(-${this.stepWidth / 2}px, -${this.stepHeight / 2}px)`);
        this.showArrow = false;
    }
    /**
     * @private
     * @return {?}
     */
    adjustLeftPosition() {
        if (this.leftPosition < 0) {
            this.arrowLeftPosition =
                this.arrowLeftPosition +
                    this.leftPosition -
                    DEFAULT_DISTANCE_FROM_MARGIN_LEFT;
            this.leftPosition = DEFAULT_DISTANCE_FROM_MARGIN_LEFT;
        }
    }
    /**
     * @private
     * @return {?}
     */
    adjustRightPosition() {
        /** @type {?} */
        let currentWindowWidth = document.body.clientWidth;
        if (this.stepAbsoluteLeft + this.stepWidth > currentWindowWidth) {
            /** @type {?} */
            let newLeftPos = this.leftPosition -
                (this.stepAbsoluteLeft +
                    this.stepWidth +
                    DEFAULT_DISTANCE_FROM_MARGIN_RIGHT -
                    currentWindowWidth);
            /** @type {?} */
            let deltaLeftPosition = newLeftPos - this.leftPosition;
            this.leftPosition = newLeftPos;
            this.arrowLeftPosition = this.arrowLeftPosition - deltaLeftPosition;
        }
    }
    /**
     * @private
     * @return {?}
     */
    adjustTopPosition() {
        if (this.stepAbsoluteTop < 0) {
            this.arrowTopPosition =
                this.arrowTopPosition +
                    this.topPosition -
                    DEFAULT_DISTANCE_FROM_MARGIN_TOP;
            this.topPosition = DEFAULT_DISTANCE_FROM_MARGIN_TOP;
        }
    }
    /**
     * @private
     * @return {?}
     */
    adjustBottomPosition() {
        if (this.stepAbsoluteTop + this.stepHeight > this.documentHeight) {
            /** @type {?} */
            let newTopPos = this.topPosition -
                (this.stepAbsoluteTop +
                    this.stepHeight +
                    DEFAULT_DISTANCE_FROM_MARGIN_BOTTOM -
                    this.documentHeight);
            /** @type {?} */
            let deltaTopPosition = newTopPos - this.topPosition;
            this.topPosition = newTopPos;
            this.arrowTopPosition = this.arrowTopPosition - deltaTopPosition;
        }
    }
    /**
     * @private
     * @return {?}
     */
    autofixTopPosition() {
        if (this.positionAlreadyFixed) {
            this.logger.warn('No step positions found for this step. The step will be centered.');
        }
        else if (this.targetAbsoluteTop - this.stepHeight - this.arrowSize <
            0) {
            this.positionAlreadyFixed = true;
            this.setStyleRight();
        }
    }
    /**
     * @private
     * @return {?}
     */
    autofixRightPosition() {
        if (this.targetAbsoluteLeft +
            this.targetWidth +
            this.stepWidth +
            this.arrowSize >
            document.body.clientWidth) {
            this.setStyleBottom();
        }
    }
    /**
     * @private
     * @return {?}
     */
    autofixBottomPosition() {
        if (this.targetAbsoluteTop +
            this.stepHeight +
            this.arrowSize +
            this.targetHeight >
            this.documentHeight) {
            this.setStyleLeft();
        }
    }
    /**
     * @private
     * @return {?}
     */
    autofixLeftPosition() {
        if (this.targetAbsoluteLeft - this.stepWidth - this.arrowSize < 0) {
            this.setStyleTop();
        }
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToResizeEvents() {
        return this.eventListenerService.resizeEvent.subscribe((/**
         * @return {?}
         */
        () => {
            this.redrawStep();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    redrawStep() {
        this.updateStepDimensions();
        this.drawStep();
    }
    /**
     * @private
     * @param {?} width
     * @param {?} height
     * @param {?} aspectRatio
     * @return {?}
     */
    getDimensionsByAspectRatio(width, height, aspectRatio) {
        /** @type {?} */
        let calcHeight = (width + height) / (1 + aspectRatio);
        /** @type {?} */
        let calcWidth = calcHeight * aspectRatio;
        return {
            width: calcWidth,
            height: calcHeight
        };
    }
    /**
     * @private
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    adjustDimensions(width, height) {
        /** @type {?} */
        let area = width * height;
        /** @type {?} */
        let newWidth = width;
        /** @type {?} */
        let newHeight = height;
        if (width > STEP_MAX_WIDTH) {
            newWidth = STEP_MAX_WIDTH;
            newHeight = area / newWidth;
        }
        else if (width < STEP_MIN_WIDTH) {
            newWidth = STEP_MIN_WIDTH;
            newHeight = STEP_MIN_WIDTH / ASPECT_RATIO;
        }
        return {
            width: newWidth,
            height: newHeight
        };
    }
    /**
     * @private
     * @return {?}
     */
    updateStepDimensions() {
        this.stepWidth = this.stepContainer.nativeElement.clientWidth;
        this.stepHeight = this.stepContainer.nativeElement.clientHeight;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        subscription => {
            subscription.unsubscribe();
        }));
    }
}
JoyrideStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'joyride-step',
                template: "<div #stepHolder class=\"joyride-step__holder\" [id]=\"'joyride-step-' + step.name\" [style.top.px]=\"topPosition\" [style.left.px]=\"leftPosition\">\r\n    <joyride-arrow *ngIf=\"showArrow\" class=\"joyride-step__arrow\" [position]=\"arrowPosition\" [style.top.px]=\"arrowTopPosition\"\r\n        [style.left.px]=\"arrowLeftPosition\"></joyride-arrow>\r\n    <div #stepContainer class=\"joyride-step__container\">\r\n        <joy-close-button class=\"joyride-step__close\" (click)=\"close()\"></joy-close-button>\r\n        <div class=\"joyride-step__header\">\r\n            <div class=\"joyride-step__title\" [style.color]=\"themeColor\">{{ title | async }}</div>\r\n        </div>\r\n        <div class=\"joyride-step__body\">\r\n            <ng-container *ngTemplateOutlet=\"customContent ? customContent : defaultContent; context: ctx\"></ng-container>\r\n            <ng-template #defaultContent>\r\n                {{ text | async }}\r\n            </ng-template>\r\n        </div>\r\n        <div class=\"joyride-step__footer\">\r\n            <div *ngIf=\"isCounterVisible\" class=\"joyride-step__counter-container\">\r\n                <ng-container *ngTemplateOutlet=\"customCounter ? customCounter : defaultCounter; context: counterData\"></ng-container>\r\n                <ng-template #defaultCounter>\r\n                    <div class=\"joyride-step__counter\">{{ counter }}</div>\r\n                </ng-template>\r\n            </div>\r\n            <div class=\"joyride-step__buttons-container\">\r\n                <div class=\"joyride-step__prev-container joyride-step__button\" *ngIf=\"isPrevButtonVisible && !isFirstStep()\" (click)=\"prev()\">\r\n                    <ng-container *ngTemplateOutlet=\"customPrevButton ? customPrevButton : defaultPrevButton\"></ng-container>\r\n                    <ng-template #defaultPrevButton>\r\n                        <joyride-button class=\"joyride-step__prev-button\" [color]=\"themeColor\">{{ prevText | async }}</joyride-button>\r\n                    </ng-template>\r\n                </div>\r\n                <div class=\"joyride-step__next-container joyride-step__button\" *ngIf=\"!isLastStep(); else doneButton\" (click)=\"next()\">\r\n                    <ng-container *ngTemplateOutlet=\"customNextButton ? customNextButton : defaulNextButton\"></ng-container>\r\n                    <ng-template #defaulNextButton>\r\n                        <joyride-button [color]=\"themeColor\">{{ nextText | async }}</joyride-button>\r\n                    </ng-template>\r\n                </div>\r\n                <ng-template #doneButton>\r\n                    <div class=\"joyride-step__done-container joyride-step__button\" (click)=\"close()\">\r\n                        <ng-container *ngTemplateOutlet=\"customDoneButton ? customDoneButton : defaultDoneButton\"></ng-container>\r\n                        <ng-template #defaultDoneButton>\r\n                            <joyride-button class=\"joyride-step__done-button\" [color]=\"themeColor\">{{ doneText | async }}</joyride-button>\r\n                        </ng-template>\r\n                    </div>\r\n                </ng-template>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".joyride-step__holder{position:absolute;font-family:Arial,Helvetica,sans-serif;font-size:16px;z-index:1001}.joyride-step__arrow{position:absolute;left:40px;z-index:1002}.joyride-step__container{box-sizing:border-box;position:relative;color:#000;background-color:#fff;display:flex;flex-direction:column;justify-content:space-between;padding:10px;box-shadow:0 0 30px 1px #000}.joyride-step__header{display:flex;align-items:center;padding:8px}.joyride-step__title{font-weight:700;font-size:20px}.joyride-step__close{position:absolute;right:10px;top:10px;width:14px;height:14px;cursor:pointer}.joyride-step__body{text-align:left;padding:10px 8px}.joyride-step__footer{display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding-left:8px}.joyride-step__buttons-container{display:flex;flex-direction:row}.joyride-step__button:first-child{margin-right:2.5px}.joyride-step__button:last-child{margin-left:2.5px}.joyride-step__counter{font-weight:700;font-size:14px}.joyride-step__counter-container{margin-right:10px}"]
            }] }
];
/** @nocollapse */
JoyrideStepComponent.ctorParameters = () => [
    { type: Injector },
    { type: JoyrideStepsContainerService },
    { type: EventListenerService },
    { type: DocumentService },
    { type: Renderer2 },
    { type: LoggerService },
    { type: JoyrideOptionsService },
    { type: TemplatesService }
];
JoyrideStepComponent.propDecorators = {
    step: [{ type: Input }],
    stepHolder: [{ type: ViewChild, args: ['stepHolder', { static: true },] }],
    stepContainer: [{ type: ViewChild, args: ['stepContainer', { static: true },] }]
};
if (false) {
    /** @type {?} */
    JoyrideStepComponent.prototype.stepWidth;
    /** @type {?} */
    JoyrideStepComponent.prototype.stepHeight;
    /** @type {?} */
    JoyrideStepComponent.prototype.leftPosition;
    /** @type {?} */
    JoyrideStepComponent.prototype.topPosition;
    /** @type {?} */
    JoyrideStepComponent.prototype.showArrow;
    /** @type {?} */
    JoyrideStepComponent.prototype.arrowPosition;
    /** @type {?} */
    JoyrideStepComponent.prototype.arrowLeftPosition;
    /** @type {?} */
    JoyrideStepComponent.prototype.arrowTopPosition;
    /** @type {?} */
    JoyrideStepComponent.prototype.title;
    /** @type {?} */
    JoyrideStepComponent.prototype.text;
    /** @type {?} */
    JoyrideStepComponent.prototype.counter;
    /** @type {?} */
    JoyrideStepComponent.prototype.isCounterVisible;
    /** @type {?} */
    JoyrideStepComponent.prototype.isPrevButtonVisible;
    /** @type {?} */
    JoyrideStepComponent.prototype.themeColor;
    /** @type {?} */
    JoyrideStepComponent.prototype.customContent;
    /** @type {?} */
    JoyrideStepComponent.prototype.customPrevButton;
    /** @type {?} */
    JoyrideStepComponent.prototype.customNextButton;
    /** @type {?} */
    JoyrideStepComponent.prototype.customDoneButton;
    /** @type {?} */
    JoyrideStepComponent.prototype.customCounter;
    /** @type {?} */
    JoyrideStepComponent.prototype.counterData;
    /** @type {?} */
    JoyrideStepComponent.prototype.ctx;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.arrowSize;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.stepAbsoluteLeft;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.stepAbsoluteTop;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.targetWidth;
    /** @type {?} */
    JoyrideStepComponent.prototype.targetHeight;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.targetAbsoluteLeft;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.targetAbsoluteTop;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.subscriptions;
    /** @type {?} */
    JoyrideStepComponent.prototype.joyrideStepService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.positionAlreadyFixed;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.documentHeight;
    /** @type {?} */
    JoyrideStepComponent.prototype.prevText;
    /** @type {?} */
    JoyrideStepComponent.prototype.nextText;
    /** @type {?} */
    JoyrideStepComponent.prototype.doneText;
    /** @type {?} */
    JoyrideStepComponent.prototype.step;
    /** @type {?} */
    JoyrideStepComponent.prototype.stepHolder;
    /** @type {?} */
    JoyrideStepComponent.prototype.stepContainer;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.stepsContainerService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.eventListenerService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.documentService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.logger;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.optionsService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepComponent.prototype.templateService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/arrow/arrow.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideArrowComponent {
    constructor() {
        this.position = 'top';
    }
}
JoyrideArrowComponent.decorators = [
    { type: Component, args: [{
                selector: 'joyride-arrow',
                template: "<div [class.joyride-arrow__top]=\"position == 'top'\"\r\n     [class.joyride-arrow__bottom]=\"position == 'bottom'\"\r\n     [class.joyride-arrow__left]=\"position == 'left'\"\r\n     [class.joyride-arrow__right]=\"position == 'right'\">\r\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".joyride-arrow__top{border-left:11px solid transparent;border-right:11px solid transparent;border-bottom:11px solid #fff}.joyride-arrow__bottom{border-left:11px solid transparent;border-right:11px solid transparent;border-top:11px solid #fff}.joyride-arrow__right{border-left:11px solid #fff;border-bottom:11px solid transparent;border-top:11px solid transparent}.joyride-arrow__left{border-right:11px solid #fff;border-top:11px solid transparent;border-bottom:11px solid transparent}"]
            }] }
];
JoyrideArrowComponent.propDecorators = {
    position: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    JoyrideArrowComponent.prototype.position;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/button/button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideButtonComponent {
    constructor() {
        this.clicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.clicked.emit();
    }
}
JoyrideButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'joyride-button',
                template: "<button (mouseleave)=\"hover=false\" (mouseover)=\"hover=true\"\r\n    [ngStyle]=\"{'background-color': hover ? '#fff' : color, \r\n                'color': hover ? color : '#fff',\r\n                'border-color' : hover ? color : 'transparent'}\"\r\n    class=\"joyride-button\" (click)=\"onClick()\">\r\n    <ng-content></ng-content>\r\n</button>",
                styles: [".joyride-button{text-transform:uppercase;border:2px solid transparent;outline:0;padding:6px 12px;font-size:12px;font-weight:700;color:#fff;background-color:#3b5560;cursor:pointer}.joyride-button:hover{color:#3b5560;border:2px solid #3b5560;background-color:#fff}"]
            }] }
];
JoyrideButtonComponent.propDecorators = {
    color: [{ type: Input }],
    clicked: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    JoyrideButtonComponent.prototype.hover;
    /** @type {?} */
    JoyrideButtonComponent.prototype.color;
    /** @type {?} */
    JoyrideButtonComponent.prototype.clicked;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/close-button/close-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideCloseButtonComponent {
}
JoyrideCloseButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'joy-close-button',
                template: `<svg viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg">
                <line x1="1" y1="24" 
                    x2="24" y2="1" 
                    stroke="black" 
                    stroke-width="3"/>
                <line x1="1" y1="1" 
                    x2="24" y2="24" 
                    stroke="black" 
                    stroke-width="3"/>
            </svg>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/step-drawer.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepDrawerService {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} appRef
     * @param {?} injector
     */
    constructor(componentFactoryResolver, appRef, injector) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.injector = injector;
        this.refMap = {};
    }
    /**
     * @param {?} step
     * @return {?}
     */
    draw(step) {
        // 1. Create a component reference from the component
        /** @type {?} */
        const ref = this.componentFactoryResolver
            .resolveComponentFactory(JoyrideStepComponent)
            .create(this.injector);
        // 2. Attach component to the appRef so that it's inside the ng component tree
        this.appRef.attachView(ref.hostView);
        // 3. Get DOM element from component
        /** @type {?} */
        const domElem = (/** @type {?} */ (((/** @type {?} */ (ref.hostView)))
            .rootNodes[0]));
        // 4. Append DOM element to the body
        document.body.appendChild(domElem);
        /** @type {?} */
        const instance = ref.instance;
        instance.step = step;
        ref.changeDetectorRef.detectChanges();
        step.stepInstance = instance;
        this.refMap[step.name] = ref;
    }
    /**
     * @param {?} step
     * @return {?}
     */
    remove(step) {
        this.appRef.detachView(this.refMap[step.name].hostView);
        this.refMap[step.name].destroy();
    }
}
StepDrawerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StepDrawerService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StepDrawerService.prototype.refMap;
    /**
     * @type {?}
     * @private
     */
    StepDrawerService.prototype.componentFactoryResolver;
    /**
     * @type {?}
     * @private
     */
    StepDrawerService.prototype.appRef;
    /**
     * @type {?}
     * @private
     */
    StepDrawerService.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/joyride-step.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SCROLLBAR_SIZE = 20;
/** @type {?} */
const DISTANCE_FROM_TARGET = 15;
/** @type {?} */
const ARROW_SIZE = 10;
/**
 * @record
 */
function IJoyrideStepService() { }
if (false) {
    /**
     * @return {?}
     */
    IJoyrideStepService.prototype.startTour = function () { };
    /**
     * @return {?}
     */
    IJoyrideStepService.prototype.close = function () { };
    /**
     * @return {?}
     */
    IJoyrideStepService.prototype.prev = function () { };
    /**
     * @return {?}
     */
    IJoyrideStepService.prototype.next = function () { };
}
class JoyrideStepService {
    /**
     * @param {?} backDropService
     * @param {?} eventListener
     * @param {?} stepsContainerService
     * @param {?} documentService
     * @param {?} DOMService
     * @param {?} stepDrawerService
     * @param {?} optionsService
     * @param {?} router
     * @param {?} logger
     */
    constructor(backDropService, eventListener, stepsContainerService, documentService, DOMService, stepDrawerService, optionsService, router, logger) {
        this.backDropService = backDropService;
        this.eventListener = eventListener;
        this.stepsContainerService = stepsContainerService;
        this.documentService = documentService;
        this.DOMService = DOMService;
        this.stepDrawerService = stepDrawerService;
        this.optionsService = optionsService;
        this.router = router;
        this.logger = logger;
        this.winTopPosition = 0;
        this.winBottomPosition = 0;
        this.stepsObserver = new ReplaySubject();
        this.initViewportPositions();
        this.subscribeToScrollEvents();
        this.subscribeToResizeEvents();
    }
    /**
     * @private
     * @return {?}
     */
    initViewportPositions() {
        this.winTopPosition = 0;
        this.winBottomPosition = this.DOMService.getNativeWindow().innerHeight - SCROLLBAR_SIZE;
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToScrollEvents() {
        this.eventListener.startListeningScrollEvents();
        this.eventListener.scrollEvent.subscribe((/**
         * @param {?} scroll
         * @return {?}
         */
        scroll => {
            this.winTopPosition = scroll.scrollY;
            this.winBottomPosition = this.winTopPosition + this.DOMService.getNativeWindow().innerHeight - SCROLLBAR_SIZE;
            if (this.currentStep)
                this.backDropService.redraw(this.currentStep, scroll);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToResizeEvents() {
        this.eventListener.resizeEvent.subscribe((/**
         * @return {?}
         */
        () => {
            if (this.currentStep)
                this.backDropService.redrawTarget(this.currentStep);
        }));
    }
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    drawStep(step) {
        step.position = step.position === NO_POSITION ? this.optionsService.getStepDefaultPosition() : step.position;
        this.stepDrawerService.draw(step);
    }
    /**
     * @return {?}
     */
    startTour() {
        this.stepsObserver = new ReplaySubject();
        this.stepsContainerService.init();
        this.documentService.setDocumentHeight();
        this.tryShowStep(StepActionType.NEXT);
        this.eventListener.startListeningResizeEvents();
        this.subscribeToStepsUpdates();
        return this.stepsObserver.asObservable();
    }
    /**
     * @return {?}
     */
    close() {
        this.removeCurrentStep();
        this.notifyTourIsFinished();
        this.DOMService.getNativeWindow().scrollTo(0, 0);
        this.eventListener.stopListeningResizeEvents();
        this.backDropService.remove();
    }
    /**
     * @return {?}
     */
    prev() {
        this.removeCurrentStep();
        this.currentStep.prevCliked.emit();
        this.tryShowStep(StepActionType.PREV);
    }
    /**
     * @return {?}
     */
    next() {
        this.removeCurrentStep();
        this.currentStep.nextClicked.emit();
        this.tryShowStep(StepActionType.NEXT);
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    navigateToStepPage(action) {
        /** @type {?} */
        let stepRoute = this.stepsContainerService.getStepRoute(action);
        if (stepRoute) {
            this.router.navigate([stepRoute]);
        }
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToStepsUpdates() {
        this.stepsContainerService.stepHasBeenModified.subscribe((/**
         * @param {?} updatedStep
         * @return {?}
         */
        updatedStep => {
            if (this.currentStep && this.currentStep.name === updatedStep.name) {
                this.currentStep = updatedStep;
            }
        }));
    }
    /**
     * @private
     * @param {?} actionType
     * @return {?}
     */
    tryShowStep(actionType) {
        this.navigateToStepPage(actionType);
        /** @type {?} */
        const timeout = this.optionsService.getWaitingTime();
        if (timeout > 100)
            this.backDropService.remove();
        setTimeout((/**
         * @return {?}
         */
        () => {
            try {
                this.showStep(actionType);
            }
            catch (error) {
                if (error instanceof JoyrideStepDoesNotExist) {
                    this.tryShowStep(actionType);
                }
                else if (error instanceof JoyrideStepOutOfRange) {
                    this.logger.error('Forcing the tour closure: First or Last step not found in the DOM.');
                    this.close();
                }
                else {
                    throw new Error(error);
                }
            }
        }), timeout);
    }
    /**
     * @private
     * @param {?} actionType
     * @return {?}
     */
    showStep(actionType) {
        this.currentStep = this.stepsContainerService.get(actionType);
        if (this.currentStep == null)
            throw new JoyrideStepDoesNotExist('');
        // Scroll the element to get it visible if it's in a scrollable element
        this.scrollIfElementBeyondOtherElements();
        this.backDropService.draw(this.currentStep);
        this.drawStep(this.currentStep);
        this.scrollIfStepAndTargetAreNotVisible();
        this.notifyStepClicked(actionType);
    }
    /**
     * @private
     * @param {?} actionType
     * @return {?}
     */
    notifyStepClicked(actionType) {
        /** @type {?} */
        let stepInfo = {
            number: this.stepsContainerService.getStepNumber(this.currentStep.name),
            name: this.currentStep.name,
            route: this.currentStep.route,
            actionType
        };
        this.stepsObserver.next(stepInfo);
    }
    /**
     * @private
     * @return {?}
     */
    notifyTourIsFinished() {
        if (this.currentStep)
            this.currentStep.tourDone.emit();
        this.stepsObserver.complete();
    }
    /**
     * @private
     * @return {?}
     */
    removeCurrentStep() {
        if (this.currentStep)
            this.stepDrawerService.remove(this.currentStep);
    }
    /**
     * @private
     * @return {?}
     */
    scrollIfStepAndTargetAreNotVisible() {
        this.scrollWhenTargetOrStepAreHiddenBottom();
        this.scrollWhenTargetOrStepAreHiddenTop();
    }
    /**
     * @private
     * @return {?}
     */
    scrollWhenTargetOrStepAreHiddenBottom() {
        /** @type {?} */
        let totalTargetBottom = this.getMaxTargetAndStepBottomPosition();
        if (totalTargetBottom > this.winBottomPosition) {
            this.DOMService.getNativeWindow().scrollBy(0, totalTargetBottom - this.winBottomPosition);
        }
    }
    /**
     * @private
     * @return {?}
     */
    scrollWhenTargetOrStepAreHiddenTop() {
        /** @type {?} */
        let totalTargetTop = this.getMaxTargetAndStepTopPosition();
        if (totalTargetTop < this.winTopPosition) {
            this.DOMService.getNativeWindow().scrollBy(0, totalTargetTop - this.winTopPosition);
        }
    }
    /**
     * @private
     * @return {?}
     */
    getMaxTargetAndStepBottomPosition() {
        /** @type {?} */
        let targetAbsoluteTop = this.documentService.getElementAbsoluteTop(this.currentStep.targetViewContainer.element);
        if (this.currentStep.position === 'top') {
            return targetAbsoluteTop + this.currentStep.stepInstance.targetHeight;
        }
        else if (this.currentStep.position === 'bottom') {
            return (targetAbsoluteTop +
                this.currentStep.stepInstance.targetHeight +
                this.currentStep.stepInstance.stepHeight +
                ARROW_SIZE +
                DISTANCE_FROM_TARGET);
        }
        else if (this.currentStep.position === 'right' || this.currentStep.position === 'left') {
            return Math.max(targetAbsoluteTop + this.currentStep.stepInstance.targetHeight, targetAbsoluteTop + this.currentStep.stepInstance.targetHeight / 2 + this.currentStep.stepInstance.stepHeight / 2);
        }
    }
    /**
     * @private
     * @return {?}
     */
    getMaxTargetAndStepTopPosition() {
        /** @type {?} */
        let targetAbsoluteTop = this.documentService.getElementAbsoluteTop(this.currentStep.targetViewContainer.element);
        if (this.currentStep.position === 'top') {
            return targetAbsoluteTop - (this.currentStep.stepInstance.stepHeight + ARROW_SIZE + DISTANCE_FROM_TARGET);
        }
        else if (this.currentStep.position === 'bottom') {
            return targetAbsoluteTop;
        }
        else if (this.currentStep.position === 'right' || this.currentStep.position === 'left') {
            return Math.min(targetAbsoluteTop, targetAbsoluteTop + this.currentStep.stepInstance.targetHeight / 2 - this.currentStep.stepInstance.stepHeight / 2);
        }
    }
    /**
     * @private
     * @return {?}
     */
    scrollIfElementBeyondOtherElements() {
        if (this.isElementBeyondOthers() === 2) {
            this.documentService.scrollToTheTop(this.currentStep.targetViewContainer.element);
        }
        if (this.isElementBeyondOthers() === 2) {
            this.documentService.scrollToTheBottom(this.currentStep.targetViewContainer.element);
        }
        if (this.isElementBeyondOthers() === 1 && this.documentService.isParentScrollable(this.currentStep.targetViewContainer.element)) {
            this.documentService.scrollIntoView(this.currentStep.targetViewContainer.element, this.currentStep.isElementOrAncestorFixed);
        }
        if (this.isElementBeyondOthers() === 1 && this.documentService.isParentScrollable(this.currentStep.targetViewContainer.element)) {
            this.currentStep.targetViewContainer.element.nativeElement.scrollIntoView();
        }
    }
    /**
     * @private
     * @return {?}
     */
    isElementBeyondOthers() {
        return this.documentService.isElementBeyondOthers(this.currentStep.targetViewContainer.element, this.currentStep.isElementOrAncestorFixed, 'backdrop');
    }
}
JoyrideStepService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
JoyrideStepService.ctorParameters = () => [
    { type: JoyrideBackdropService },
    { type: EventListenerService },
    { type: JoyrideStepsContainerService },
    { type: DocumentService },
    { type: DomRefService },
    { type: StepDrawerService },
    { type: JoyrideOptionsService },
    { type: Router },
    { type: LoggerService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.currentStep;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.winTopPosition;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.winBottomPosition;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.stepsObserver;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.backDropService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.eventListener;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.stepsContainerService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.documentService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.DOMService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.stepDrawerService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.optionsService;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.router;
    /**
     * @type {?}
     * @private
     */
    JoyrideStepService.prototype.logger;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/joyride-step-info.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideStepInfo {
}
if (false) {
    /** @type {?} */
    JoyrideStepInfo.prototype.number;
    /** @type {?} */
    JoyrideStepInfo.prototype.name;
    /** @type {?} */
    JoyrideStepInfo.prototype.route;
    /** @type {?} */
    JoyrideStepInfo.prototype.actionType;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/joyride.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoyrideService {
    /**
     * @param {?} platformId
     * @param {?} stepService
     * @param {?} optionsService
     */
    constructor(platformId, stepService, optionsService) {
        this.platformId = platformId;
        this.stepService = stepService;
        this.optionsService = optionsService;
        this.tourInProgress = false;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    startTour(options) {
        if (!isPlatformBrowser(this.platformId)) {
            return of(new JoyrideStepInfo());
        }
        if (!this.tourInProgress) {
            this.tourInProgress = true;
            if (options) {
                this.optionsService.setOptions(options);
            }
            this.tour$ = this.stepService.startTour().pipe(finalize((/**
             * @return {?}
             */
            () => (this.tourInProgress = false))));
            this.tour$.subscribe();
        }
        return this.tour$;
    }
    /**
     * @return {?}
     */
    closeTour() {
        if (this.isTourInProgress())
            this.stepService.close();
    }
    /**
     * @return {?}
     */
    isTourInProgress() {
        return this.tourInProgress;
    }
}
JoyrideService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
JoyrideService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: JoyrideStepService },
    { type: JoyrideOptionsService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    JoyrideService.prototype.tourInProgress;
    /**
     * @type {?}
     * @private
     */
    JoyrideService.prototype.tour$;
    /**
     * @type {?}
     * @private
     */
    JoyrideService.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    JoyrideService.prototype.stepService;
    /**
     * @type {?}
     * @private
     */
    JoyrideService.prototype.optionsService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/joyride.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const routerModuleForChild = RouterModule.forChild([]);
class JoyrideModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: JoyrideModule,
            providers: [
                JoyrideService,
                JoyrideStepService,
                JoyrideStepsContainerService,
                JoyrideBackdropService,
                EventListenerService,
                DocumentService,
                JoyrideOptionsService,
                StepDrawerService,
                DomRefService,
                LoggerService,
                TemplatesService
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: JoyrideModule,
            providers: []
        };
    }
}
JoyrideModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, routerModuleForChild],
                declarations: [
                    JoyrideDirective,
                    JoyrideStepComponent,
                    JoyrideArrowComponent,
                    JoyrideButtonComponent,
                    JoyrideCloseButtonComponent
                ],
                entryComponents: [JoyrideStepComponent],
                exports: [
                    JoyrideDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/joyride.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-joyride.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ARROW_SIZE, DEFAULT_DISTANCE_FROM_MARGIN_LEFT, DEFAULT_DISTANCE_FROM_MARGIN_TOP, DEFAULT_TEXTS, DEFAULT_THEME_COLOR, DEFAULT_TIMEOUT_BETWEEN_STEPS, DISTANCE_FROM_TARGET, DocumentService, DomRefService, EventListenerService, JoyrideArrowComponent, JoyrideBackdropService, JoyrideButtonComponent, JoyrideCloseButtonComponent, JoyrideDirective, JoyrideModule, JoyrideOptionsService, JoyrideService, JoyrideStepComponent, JoyrideStepService, JoyrideStepsContainerService, LoggerService, NO_POSITION, ObservableCustomTexts, STEP_DEFAULT_POSITION, Scroll, StepActionType, StepDrawerService, TemplatesService, routerModuleForChild };
//# sourceMappingURL=ngx-joyride.js.map
